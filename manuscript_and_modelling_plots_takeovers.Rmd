---
title: "manuscript_modelling_and_plots_takeovers"
author: "Courtney Goodridge"
date: "14/02/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

The code in this script produces the plots and model for the following manuscript:

# Packages

Loading packages that will be used for this analysis

```{r}
if(!require(here)) install.packages("here")
library(here)

if(!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)

if(!require(dplyr)) install.packages("dplyr")
library(dplyr)

if(!require(tidyr)) install.packages("tidyr")
library(tidyr)

if(!require(viridis)) install.packages("viridis")
library(viridis)

if(!require(gridExtra)) install.packages("gridExtra")
library(gridExtra)

if(!require(readr)) install.packages("readr")
library(readr)

if(!require(plyr)) install.packages("plyr")
library(plyr)

if(!require(stringr)) install.packages("stringr")
library(stringr)

if(!require(readxl)) install.packages("readxl")
library(readxl)

if(!require(data.table)) install.packages("data.table")
library(data.table)

if(!require(xfun)) install.packages("xfun")
library(xfun)

if(!require(cowplot)) install.packages("cowplot")
library(cowplot)

if(!require(gganimate)) install.packages("gganimate")
library(gganimate)

if(!require(ggExtra)) install.packages("ggExtra")
library(ggExtra)

if(!require(plotly)) install.packages("plotly")
library(plotly)

if(!require(brms)) install.packages("brms")
library(brms)

if(!require(bayestestR)) install.packages("bayestestR")
library(bayestestR)

if(!require(emmeans)) install.packages("emmeans")
library(emmeans)

if(!require(ROSE)) install.packages("ROSE")
library(ROSE)

if(!require(Rmisc)) install.packages("Rmisc")
library(Rmisc)

if(!require(metafolio)) install.packages("metafolio")
library(metafolio)

if(!require(tibble)) install.packages("tibble")
library(tibble)

if(!require(modelr)) install.packages("modelr")
library(modelr)

if(!require(tidybayes)) install.packages("tidybayes")
library(tidybayes)

if(!require(mgcv)) install.packages("mgcv")
library(mgcv)

if(!require(ciTools)) install.packages("ciTools")
library(ciTools)

if(!require(gratia)) install.packages("gratia")
library(gratia)

if(!require(scales)) install.packages("scales")
library(scales)

if(!require(patchwork)) install.packages("patchwork")
library(patchwork)

if(!require(ggforce)) install.packages("ggforce")
library(ggforce)
```

# Load vehicle data

This provides timing responses to takeovers and collision data. We also remove participants that were removed in the gaze entropy analysis. 

```{r}
# response data frame for vehicle and eye data per trial
response.vehicle.eye <- fread(file = here::here("takeover_performance_cogload_time_budget/Data/takeover.responses.critical.lat.long.csv"))

# removing participants from vehicle and gaze data
response.vehicle.eye <- response.vehicle.eye %>%
  dplyr::filter(ppid != 34, ppid != 39, ppid != 47) %>%
  tidyr::drop_na()

# make collision data 1s and 0s
response.vehicle.eye <- response.vehicle.eye %>%
  dplyr::mutate(collision = case_when(collision == TRUE ~ 1,
                                      collision == FALSE ~ 0))
```

# Load participant information

```{r}
# select demographic data such as age, annual miles driven, years with license
participant.info <- read.csv(here::here("gaze_entropy_heterogenous/data/participant_info.csv")) %>%
  dplyr::select(1:5) %>%
  dplyr::rename("age" = "Ã¯..Age", "ppid" = "Participant.ID")

# combine entropy dataframe with the participant information dataframe
response.vehicle.eye <- merge(response.vehicle.eye, participant.info, by = c("ppid"))

# some of these variables are added into the models later. To maintain numerical stability, they are centre so that the mean is 0 
response.vehicle.eye$age.c <- scale(response.vehicle.eye$age, center = T, scale = F)

response.vehicle.eye$Approximate.Annual.Mileage..Miles.c <- scale(response.vehicle.eye$Approximate.Annual.Mileage..Miles., center = T, scale = F)

response.vehicle.eye$No..of.years.holding.a.full.UK.driving.license.c <- scale(response.vehicle.eye$No..of.years.holding.a.full.UK.driving.license, center = T, scale = F)
```

# Removing outliers

Thre removal of outliers should only be done if the data do not represent actual behaviour for completing the task. In this sense, tag any RTs that are more than 4 SDs away from the mean of that condition as an outlier. This rules out responses where a driver took exceptionally long to place their hands on the steering wheel following a critical event. 

```{r}
# computing outliers for braking reaction time
response.vehicle.eye <-  response.vehicle.eye %>%
  #dplyr::filter(collision == 0) %>%
  tidyr::drop_na() %>%
  dplyr::group_by(n_back, ttc_criticality.x) %>%
  dplyr::mutate(mean.rt = mean(rt), sd.rt = sd(rt)) %>%
  dplyr::mutate(sd.rt.4 =  sd.rt * 4) %>%
  dplyr::mutate(mean_4_sd = mean.rt + sd.rt.4) %>%
  dplyr::mutate(rt.outlier = rt > mean_4_sd)

# calculating outliers for hands on reaction time
response.vehicle.eye <-  response.vehicle.eye %>%
  #dplyr::filter(collision == 0) %>%
  tidyr::drop_na() %>%
  dplyr::group_by(n_back, ttc_criticality.x) %>%
  dplyr::mutate(mean.ho = mean(ho.rt), sd.ho = sd(ho.rt)) %>%
  dplyr::mutate(sd.ho.4 =  sd.ho * 4) %>%
  dplyr::mutate(mean_4_sd = mean.ho + sd.ho.4) %>%
  dplyr::mutate(ho.outlier = ho.rt > mean_4_sd)
```

# Participants demographics

```{r}
response.vehicle.eye %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::group_by(ppid) %>%
  dplyr::slice(1) %>%
  dplyr::ungroup() %>%
  dplyr::summarise(avg = mean(age), min_age = min(age), max_age = max(age), mean_milage = mean(Approximate.Annual.Mileage..Miles.), min_mileage = min(Approximate.Annual.Mileage..Miles.), max_mileage = max(Approximate.Annual.Mileage..Miles.), mean_license = mean(No..of.years.holding.a.full.UK.driving.license), min_license = min(No..of.years.holding.a.full.UK.driving.license), max_license = max(No..of.years.holding.a.full.UK.driving.license), N = n()) %>%
  View()

response.vehicle.eye %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::group_by(ppid) %>%
  dplyr::slice(1) %>%
  dplyr::group_by(Gender) %>%
  dplyr::summarise(n = n()) %>%
  View()
```

# Braking RT - model fitting

A paper by Ruscio et al (2015) proposed that braking reaction time is a multi-component cognitive skill:

1) Perception of the stimuli i.e, the looming signal towards the driver. This could realistically be detected via a change in pupil dilation as the looming lead vehicle comes to towards them
2) Time for mental processing of the situation
3) Moving foot from the accelerator pedal
4) time need to muscle to move foot toward the brake
5) Beginning of pressure on brake pedal.

In that study, they focus on braking in manual driving and thus lifting the foot from the accelerator and onto the brake is consider a component. However in the current study, driver's feet were off the pedal. Hence future work might want to begin modelling potential changes in "non-decision time" associated with event criticality and n-back. In this sense, ndt refers to steps 1 and 2.

```{r}
# loading model
braking_rt_shifted_lognormal_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/braking_rt_shifted_lognormal_maximal.rds"))

# adding a random slope for the criticality of the effect
braking_rt_shifted_lognormal_maximal <- brm(data = response.vehicle.eye %>%
                                              dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
                                              dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                                              dplyr::mutate(ppid = as.factor(ppid)), 
                                            family = shifted_lognormal(),
                                            bf(rt ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor| ppid)),
                                            prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                                      prior(student_t(3, 0, 2.5), class = "b"),
                                                      prior(lkj(2), class = cor)),
                                            iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13,
                                            file = here::here("takeover_performance_cogload_time_budget/Models/braking_rt_shifted_lognormal_maximal.rds"))

print(summary(braking_rt_shifted_lognormal_maximal), digits = 5)
describe_posterior(braking_rt_shifted_lognormal_maximal, centrality = "mean")

# posterior predictive checks
pp_check(braking_rt_shifted_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(braking_rt_shifted_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "n_back")


# posterior predictive checks
pp_check(braking_rt_shifted_lognormal_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100) 
pp_check(braking_rt_shifted_lognormal_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100) 
```

# Braking RT - model predictions

Calculating predicted braking RT implied by the model parameters, and the average effect of time budget on braking RT.

The tutorial I use to help calculate these model predictions: https://www.andrewheiss.com/blog/2021/11/10/ame-bayes-re-guide/#different-kinds-of-average-predictions-with-multilevel-models 

```{r}
# calculating the marginal effect of TTC on braking RT 
braking_rt_MER_TTC <- braking_rt_shifted_lognormal_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

braking_rt_MER_TTC  %>% mean_hdi()

# predicted global mean RTs implied by the model # setting re_formula = NA tells the function to not use any random effects - here we plot the TTC specific distributions 
predicted_braking_rt_ttc <- braking_rt_shifted_lognormal_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = FALSE),
              re_formula = NA)

predicted_braking_rt_ttc %>% mean_hdi()
```

# Braking RT - visualising posterior draws and means

In the chunk below, I plot the posterior expected values alongside the distributions, over the raw data. The function *data_grid()* produces an empty dataframe from which to generate predictions from the model (https://mjskay.github.io/tidybayes/articles/tidy-brms.html)

```{r}
# Creates long format data frame of each participant within each condition. This is new data from which we can make some predictions regarding the effects of n-back and and ttc
empty_grid = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  data_grid(n_back, ttc_criticality_factor, ppid)

# we use a new dataset to plug into the model and a generate posterior predictive distribution. For this, we take into account the uncertainty of the fixed coefficients, the uncertainty of the variance parameters (random effects), and the uncertainty of individual observations (residual variance). With the model that contains this information and the new data, we can generate predictions regarding the uncertainty of new, unobserved data points.
predicted_draws = empty_grid %>%
  add_predicted_draws(braking_rt_shifted_lognormal_maximal)

# When focusing on the marginal effects, we want to focus on the uncertainty of the parameter values, rather than individual residuals. So we can use the epred_draws() function to generate expected values. These include uncertainty of just two elements: uncertainty of the fixed effects, and uncertainty of the variance parameter (random effects). The argument re_formula = NULL is the default and thus the random effects are incorporated by default. Setting re_formula = NA removes the influences of the random effects.  

# It should be noted that for the shifted log normal distribution, E(y) = exp(mu + sigma^2 / 2 + ndt) (https://github.com/paul-buerkner/brms/blob/28f778d7933f95422dda8f9a9f4333b975261120/R/posterior_epred.R#L341)
expected_values = empty_grid %>%
  add_epred_draws(braking_rt_shifted_lognormal_maximal)

# labels
ttc_labs <- c("TTC = 3 s", "TTC = 5 s")
names(ttc_labs) <- c(as.factor(3), as.factor(5))

# expected values and model predicted means
posterior_braking_rt <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = rt, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), size = 2, height = .08, alpha = .3) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  scale_color_brewer("Posterior predictive interval") +
  ggtitle("A") +
  xlim(.5, 3.5) +
  xlab(expression(RT[B]~ "(s)")) +
  ylab(" ") +
  #scale_x_continuous(breaks = seq(.5, 3, .5), labels = label_number(accuracy = .5)) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10)) 


predicted_braking_rt_ttc_plot <- ggplot(predicted_braking_rt_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ RT[B]~ "(s)")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  xlim(1, 1.6) +
  theme_bw() +
  theme(legend.position = c(.87, .60), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# Marginal Effects at Representative values (MER) of TTC on braking RT
braking_rt_MER_TTC_plot <- ggplot(braking_rt_MER_TTC, aes(x = .value, y = " ")) +
  stat_halfeye() +
  ylab(NULL) +
  xlab(expression(MER[RT[B]]~ "(s) for TTC")) +
  ggtitle("C") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.9, .7), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig4 <- posterior_braking_rt / (predicted_braking_rt_ttc_plot | braking_rt_MER_TTC_plot)

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/Fig4.tiff"), plot = fig4, width = 16, height = 12, units = 'cm', dpi = 300, type = 'cairo')
```

# Hands-on time: model fitting

Seemingly no effect of cognitive load on hands on time. Small effect on criticality 

```{r}
# hands on time - distributions
ggplot(response.vehicle.eye %>%
                dplyr::filter(rt.outlier == FALSE, ho.rt != 0, collision == 0), mapping = aes(x = ho.rt)) +
  geom_histogram(aes(fill = as.factor(n_back)), alpha = 0.5, bins = 50, col = "black") + 
  xlab("Hands on RT (s)") +
  facet_wrap(~ ttc_criticality.x) +
  xlim(0, 3.5)

# loading model
handson_rt_shifted_lognormal_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/handson_rt_shifted_lognormal_maximal.rds"))

# adding a random slope for the criticality of the effect
handson_rt_shifted_lognormal_maximal <- brm(data = response.vehicle.eye %>%
                                                   dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>% 
                                                     dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>% 
                                                     dplyr::mutate(ppid = as.factor(ppid)),
                                                   family = shifted_lognormal(), 
                                                   bf(ho.rt ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor| ppid)),
                                                   prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                                             prior(student_t(3, 0, 2.5), class = "b"),
                                                             prior(lkj(2), class = cor)),
                                                   iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13, 
                                                   file = here::here("takeover_performance_cogload_time_budget/Models/handson_rt_shifted_lognormal_maximal"))

# posterior predictive checks
pp_check(handson_rt_shifted_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(handson_rt_shifted_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "n_back")


# posterior predictive checks
pp_check(handson_rt_shifted_lognormal_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100) 
pp_check(handson_rt_shifted_lognormal_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100) 



```

# Hands-on steering time: model predictions

```{r}
print(summary(handson_rt_shifted_lognormal_maximal), digits = 5)
describe_posterior(handson_rt_shifted_lognormal_maximal)

#### Global mean effect of TTC #### # setting re_formula = NA tells the function to not use any random effects - here we plot the n-back specific distributions 
predicted_ho_rt_ttc <- handson_rt_shifted_lognormal_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = FALSE),
              re_formula = NA)

predicted_ho_rt_ttc %>% mean_hdi()

# and now we plot the distribution of the difference between n_back and no n-back 
ho_rt_MER_TTC <- handson_rt_shifted_lognormal_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

ho_rt_MER_TTC %>% mean_hdi()
```

# Hands-on steering time - visualising posterior draws and means

```{r}
#### predicted posterior means and distribution ####
predicted_draws = empty_grid %>%
  add_predicted_draws(handson_rt_shifted_lognormal_maximal)

expected_values = empty_grid %>%
  add_epred_draws(handson_rt_shifted_lognormal_maximal)

# labels
ttc_labs <- c("TTC = 3 s", "TTC = 5 s")
names(ttc_labs) <- c(as.factor(3), as.factor(5))

posterior_ho_rt <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = ho.rt, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), size = 2, height = .05, alpha = .3) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  scale_color_brewer("Posterior predictive interval") +
  ggtitle("A") +
  xlim(.5, 3.5) +
  xlab(expression(RT[HO]~ "(s)")) +
  ylab(" ") +
  #scale_x_continuous(limits = c(0, 3.5), breaks = seq(0, 3, .5), labels = label_number(accuracy = .5)) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10)) 


# predicted hands-on time 
predicted_ho_rt_ttc_plot <- ggplot(predicted_ho_rt_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ RT[HO]~ "(s)")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.88, .60), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))


# MER of TTC on hands on RT
ho_rt_MER_TTC_plot <- ggplot(ho_rt_MER_TTC, aes(x = .value, y = " ")) +
  stat_halfeye() +
  ylab(NULL) +
  xlab(expression(MER[RT[HO]]~ "(s) of TTC")) +
  ggtitle("C") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.93, .62), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig5 <- posterior_ho_rt / (predicted_ho_rt_ttc_plot | ho_rt_MER_TTC_plot)

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/Fig5.tiff"), plot = fig5, width = 16, height = 11, units = 'cm', dpi = 300, type = 'cairo')
```

## Mean decelerations - model fitting

- TO DO 

Calculate the average absolute lateral accelerations were and see if it correlates with maximum lateral accelerations

Find studies that talk about max decelerations being around 12 m/s^2 and how this makes modelling the response difficult by just taking the max value, but averaging over the all the decleration produces some nice fits - I think it's Gold et al or maybe Radlymayr et al who mentions the max longitudinal metric

Further investigate variance in the effect of N-back on mean deceleration. 

Check if a Gaussian produces a better fit than the skew gaussian. 

```{r}
ggplot(response.vehicle.eye %>%
         dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, ho.rt > .15, collision == 0) %>%
         dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
         dplyr::mutate(ppid = as.factor(ppid)), mapping = aes(mean_decel)) +
  geom_histogram() +
  facet_grid(~ttc_criticality_factor)

# regularising priors for parameter values
prior(student_t(5, 9, 2.5)) %>% 
  parse_dist() %>% 
  ggplot(aes(xdist = .dist_obj, y = prior)) + 
  stat_halfeye(.width = c(.5, .99)) +
  scale_y_discrete(NULL, breaks = NULL, expand = expansion(add = 0.1)) +
  scale_x_continuous(expression(italic(p)(beta[1]))) +
  theme_bw()

prior(normal(9, 2)) %>% 
  parse_dist() %>% 
  ggplot(aes(xdist = .dist_obj, y = prior)) + 
  stat_halfeye(.width = c(.5, .99)) +
  scale_y_discrete(NULL, breaks = NULL, expand = expansion(add = 0.1)) +
  scale_x_continuous(expression(italic(p)(beta[1]))) +
  theme_bw()

mean_decel_skewnormal_reg_priors_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/mean_decel_skewnormal_reg_priors_maximal.rds"))

# modelling average deceleration with regularising priors. Random effects structure is maximal. Distribution family is skew-normal. 
mean_decel_skewnormal_reg_priors_maximal <- brm(data = response.vehicle.eye %>%
                                             dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, ho.rt > .15, collision == 0) %>%
                                             dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                                             dplyr::mutate(ppid = as.factor(ppid)),
                                           family = skew_normal(),
                                           prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                                     prior(student_t(3, 0, 2.5), class = "b")),
                                           bf(mean_decel ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor | ppid)),
                                           control = list(adapt_delta = 0.99999999999),
                                           iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13,
                                           file = here::here("takeover_performance_cogload_time_budget/Models/mean_decel_skewnormal_reg_priors_maximal"))



pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "stat_grouped", stat = "mean", group = "n_back")

pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100)


d <- pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "hist", group = "ttc_criticality_factor")

ggplot(d[["data"]], mapping = aes(value)) +
  geom_histogram(aes(fill = as.factor(is_y))) +
  facet_wrap(~ rep_id)



# modelling average deceleration with regularising priors. Random effects structure is maximal. Distribution family is Gaussian.
mean_decel_gaussian_reg_priors_maximal <- brm(data = response.vehicle.eye %>%
                                             dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, ho.rt > .15, collision == 0) %>%
                                             dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                                             dplyr::mutate(ppid = as.factor(ppid)),
                                           family = gaussian(),
                                           prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                                     prior(student_t(3, 0, 2.5), class = "b")),
                                           bf(mean_decel ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor | ppid)),
                                           control = list(adapt_delta = 0.99999999999),
                                           iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13,
                                           file = here::here("takeover_performance_cogload_time_budget/Models/mean_decel_gaussian_reg_priors_maximal"))
# summarising model parameters 
print(summary(mean_decel_gaussian_reg_priors_maximal), digits = 5)
describe_posterior(mean_decel_gaussian_reg_priors_maximal, centrality = "mean")


pp_check(mean_decel_gaussian_reg_priors_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(mean_decel_gaussian_reg_priors_maximal, type = "stat_grouped", stat = "mean", group = "n_back")

pp_check(mean_decel_gaussian_reg_priors_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
pp_check(mean_decel_gaussian_reg_priors_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100)


pp_check(mean_decel_skewnormal_reg_priors_maximal, type = "hist", group = "ttc_criticality_factor")
```

# Mean decelerations: model predictions

```{r}
# summarising model parameters 
print(summary(mean_decel_skewnormal_reg_priors_maximal), digits = 5)
describe_posterior(mean_decel_skewnormal_reg_priors_maximal , centrality = "mean")

#### Global mean effect of TTC #### # setting re_formula = NA tells the function to not use any random effects - here we plot the n-back specific distributions 
predicted_mean_decel_ttc <- mean_decel_skewnormal_reg_priors_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = FALSE),
              re_formula = NA)

predicted_mean_decel_ttc %>% mean_hdi()

# effect of TTC when N-back is not TRUE
mean_decel_MER_TTC <- mean_decel_skewnormal_reg_priors_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

mean_decel_MER_TTC %>% mean_hdi()
```

## Mean decelerations: visualising posterior draws and means

```{r}
#### predicted posterior means and distribution ####
predicted_draws = empty_grid %>%
  add_predicted_draws(mean_decel_skewnormal_reg_priors_maximal)

expected_values = empty_grid %>%
  add_epred_draws(mean_decel_skewnormal_reg_priors_maximal)

# labels
ttc_labs <- c("TTC = 3 s", "TTC = 5 s")
names(ttc_labs) <- c(as.factor(3), as.factor(5))

posterior_mean_decel <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = mean_decel, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), size = 2, height = .05, alpha = .3) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  scale_color_brewer("Posterior predictive interval") +
  ggtitle("A") +
  xlim(-7, 0) +
  xlab(expression(M[D] ~"("~m/s^2~")")) +
  ylab(" ") +
  #scale_x_continuous(limits = c(0, 3.5), breaks = seq(0, 3, .5), labels = label_number(accuracy = .5)) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10)) 

# predicted mean decelerations
predicted_mean_decel_ttc_plot <- ggplot(predicted_mean_decel_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ M[D] ~ "("~m/s^2~")")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  xlim(-4, -.5) +
  theme_bw() +
  theme(legend.position = c(.88, .57), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# MER of TTC on mean deceleration
mean_decel_MER_TTC_plot <- ggplot(mean_decel_MER_TTC, aes(x = .value, y = " ")) +
  stat_halfeye() +
  ylab(NULL) +
  xlab(expression(MER[M[D]]~ "("~m/s^2~")" ~ "of TTC")) +
  ggtitle("C") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.93, .62), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig6 <- posterior_mean_decel / (predicted_mean_decel_ttc_plot | mean_decel_MER_TTC_plot)

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/Fig6.tiff"), plot = fig6, width = 16, height = 11, units = 'cm', dpi = 300, type = 'cairo')
```

## Modelling - mean lateral accelerations

```{r}
ggplot(response.vehicle.eye %>%
         dplyr::filter(rt.outlier == FALSE, ho.rt != 0, collision == 0), mapping = aes(x = mean_lat_acc)) +
  geom_histogram(aes(fill = as.factor(n_back)), alpha = 0.5, bins = 50, col = "black") +
  facet_grid(n_back ~ ttc_criticality.x)

# load model
mean_lat_acc_lognormal_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/mean_lat_acc_lognormal_maximal.rds"))

# model of maximum longitudinal acceleration with priors
mean_lat_acc_lognormal_maximal <- brm(data = response.vehicle.eye %>%
                                        dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, ho.rt > .15, collision == 0) %>%
                                        dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                                        dplyr::mutate(ppid = as.factor(ppid)),
                                      family = lognormal(),
                                      prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                                prior(student_t(3, 0, 2.5), class = "b")),
                                       bf(mean_lat_acc ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor | ppid)),
                                      control = list(adapt_delta = 0.99999999999),
                                      iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13,
                                      file = here::here("takeover_performance_cogload_time_budget/Models/mean_lat_acc_lognormal_maximal"))


pp_check(mean_lat_acc_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(mean_lat_acc_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "n_back")

pp_check(mean_lat_acc_lognormal_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
pp_check(mean_lat_acc_lognormal_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100)
```

## Mean lateral accelerations: model predictions

```{r}
print(summary(mean_lat_acc_lognormal_maximal), digits = 5)
describe_posterior(mean_lat_acc_lognormal_maximal, centrality = "mean")

# predicted lateral accelerations across all conditions
predicted_lat_acc_ttc <- mean_lat_acc_lognormal_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = c(FALSE, TRUE)),
              re_formula = NA)

predicted_lat_acc_ttc %>% mean_hdi()

# marginal effect of TTC when N-back is FALSE
lat_acc_MER_TTC_noNback <- mean_lat_acc_lognormal_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

# marginal effect of TTC when N-back is TRUE
lat_acc_MER_TTC_Nback <- mean_lat_acc_lognormal_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = TRUE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()
```

## Mean lateral accelerations - visualising posterior draws and means

```{r}
avg_lat_acc <- fread(file = here::here("takeover_performance_cogload_time_budget/Data/avg_lat_acc.csv"))

#### predicted posterior means and distribution ####
predicted_draws = empty_grid %>%
  add_predicted_draws(mean_lat_acc_lognormal_maximal)

expected_values = empty_grid %>%
  add_epred_draws(mean_lat_acc_lognormal_maximal)

posterior_mean_lat_acc <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = mean_lat_acc, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), height = .03, alpha = .2) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  ggtitle("A") +
  scale_color_brewer("Posterior predictive interval") +
  xlim(0, 1.25) +
  xlab(expression(M[LA] ~"("~m/s^2~")")) +
  ylab(" ") +
  #scale_x_continuous(breaks = seq(0, .8, .2), labels = label_number(accuracy = 0.01)) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# labels - n-back
l.labs <- c("No N-back", "N-back")
names(l.labs) <- c("FALSE", "TRUE")

# predicted mean lateral accelerations
predicted_lat_acc_ttc_plot <- ggplot(predicted_lat_acc_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ M[LA] ~ "("~m/s^2~")")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  xlim(.1, .4) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  theme_bw() +
  theme(legend.position = c(.945, .58), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# average lateral accelerations over time
avg_lat_acc_plot <- ggplot(avg_lat_acc, mapping = aes(x = timestamp_common_manual, y = lat_acc, col = as.factor(n_back))) +
  geom_path() +
  ggtitle("C") +
  ylab(expression("LA ("~m/s^2~")")) +
  xlab("Time (s)") +
  facet_wrap(~ ttc_criticality) +
  scale_color_manual(name = " ", labels = c("No N-back", "N-back"), values = viridis(3)[1:2]) +
  facet_wrap(~ ttc_criticality, labeller = labeller(ttc_criticality = ttc_labs)) +
  theme_bw() +
  theme(legend.position = c(.703, .21), legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig7 <- posterior_mean_lat_acc / predicted_lat_acc_ttc_plot

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/Fig7.tiff"), plot = fig7, width = 16, height = 12, units = 'cm', dpi = 300, type = 'cairo')
```

# SDLP: model fitting 

```{r}
# SDLP - distributions
ggplot(response.vehicle.eye %>%
                dplyr::filter(rt.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15), mapping = aes(x = sdlp)) +
  geom_histogram(aes(fill = as.factor(n_back)), alpha = 0.5, bins = 50, col = "black") + 
  xlab("SDLP") +
  facet_wrap(~ ttc_criticality.x) 

sdlp_lognormal_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/sdlp_lognormal_maximal.rds"))

# initial model of SDLP
sdlp_lognormal_maximal <- brm(data = response.vehicle.eye %>%
                                dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
                                dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                                dplyr::mutate(ppid = as.factor(ppid)),
                              family = lognormal(),
                              prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                        prior(student_t(3, 0, 2.5), class = "b")),
                              bf(sdlp ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor| ppid)),
                                   control = list(adapt_delta = 0.95),
                                   iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13, 
                                   file = here::here("takeover_performance_cogload_time_budget/Models/sdlp_lognormal_maximal"))

pp_check(sdlp_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(sdlp_lognormal_maximal, type = "stat_grouped", stat = "mean", group = "n_back")

pp_check(sdlp_lognormal_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
pp_check(sdlp_lognormal_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100)

pp_check(sdlp_lognormal_maximal, type = "hist", group = "ttc_criticality_factor")
```

# SDLP: model predictions

```{r}
print(summary(sdlp_lognormal_maximal), digits = 5)
describe_posterior(sdlp_lognormal_maximal, centrality = "mean")

#### predicted posterior means and distribution ####
predicted_draws = empty_grid %>%
  add_predicted_draws(sdlp_lognormal_maximal)

expected_values = empty_grid %>%
  add_epred_draws(sdlp_lognormal_maximal)

#### Global mean effect of TTC #### # setting re_formula = NA tells the function to not use any random effects - here we plot the n-back specific distributions 
predicted_SDLP_ttc <- sdlp_lognormal_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = FALSE),
              re_formula = NA)

predicted_SDLP_ttc  %>% mean_hdi()

# effect of TTC on SDLP when N-back is not TRUE
SDLP_MER_TTC <- sdlp_lognormal_maximal%>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

SDLP_MER_TTC %>% mean_hdi()
```

# SDLP: visualising posterior draws and means

```{r}
# labels
ttc_labs <- c("TTC = 3 s", "TTC = 5 s")
names(ttc_labs) <- c(as.factor(3), as.factor(5))

posterior_sdlp <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = sdlp, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), size = 2, height = .05, alpha = .3) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  scale_color_brewer("Posterior predictive interval") +
  ggtitle("A") +
  #xlim(.5, 3.5) +
  xlab(expression(SD[LP]~ "(m)")) +
  ylab(" ") +
  xlim(0, 2) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10)) 

# predicted means of SDLP
predicted_SDLP_ttc_plot <- ggplot(predicted_SDLP_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ SD[LP]~ "(m)")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.88, .6), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# Average marginal effect of TTC on SDLP
SDLP_MER_TTC_plot <- ggplot(SDLP_MER_TTC, aes(x = .value, y = " ")) +
  stat_halfeye() +
  ylab(NULL) +
  xlab(expression(MER[SD[LP]]~ "(m) of TTC")) +
  ggtitle("C") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.9, .7), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig8 <- posterior_sdlp / (predicted_SDLP_ttc_plot | SDLP_MER_TTC_plot)

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/fig8.tiff"), plot = fig8, width = 16, height = 12, units = 'cm', dpi = 300, type = 'cairo')
```

# SD of horitzonal gaze during automation: model fitting

```{r}
# SDLP - distributions
ggplot(response.vehicle.eye %>%
                dplyr::filter(rt.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15), mapping = aes(x = sd_yaw_automation)) +
  geom_histogram(alpha = 0.5, bins = 50, col = "black") + 
  xlab("SD yaw") +
  facet_wrap(~n_back) 

sd_yaw_automation_gaussian_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/sd_yaw_automation_gaussian_maximal.rds"))

# initial model of sd_yaw
sd_yaw_automation_gaussian_maximal <- brm(data = response.vehicle.eye %>%
                                             dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
                             dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                             dplyr::mutate(ppid = as.factor(ppid)),
                           family = gaussian(),
                           sd_yaw_automation ~ n_back + (n_back | ppid),
                           prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                     prior(student_t(3, 0, 2.5), class = "b")),
                           iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13, 
                                                   file = here::here("takeover_performance_cogload_time_budget/Models/sd_yaw_automation_gaussian_maximal"))


# posterior predictive checks
pp_check(sd_yaw_automation_gaussian_maximal, type = "stat_grouped", stat = "mean", group = "n_back")
pp_check(sd_yaw_automation_gaussian_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
```

# SD of horitzonal gaze during automation: model predictions

```{r}
# model summmary
print(summary(sd_yaw_automation_gaussian_maximal), digits = 5)
describe_posterior(sd_yaw_automation_gaussian_maximal, centrality = "mean")


# average predicted SD of yaw during automation with and without n-back
predicted_sd_yaw_automation_nback <- sd_yaw_automation_gaussian_maximal %>% 
  epred_draws(newdata = expand_grid(n_back = c(TRUE, FALSE)),
              re_formula = NA)

predicted_sd_yaw_automation_nback %>% mean_hdi()

# average marginal effect of n-back
sd_yaw_automation_MER_nback <- sd_yaw_automation_gaussian_maximal %>% 
  emmeans(~ n_back,
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

sd_yaw_automation_MER_nback  %>% mean_hdi()
```

# SD of horitzonal gaze during automation: dispersion plots

```{r}
# labels - n-back
l.labs <- c("No N-back", "N-back")
names(l.labs) <- c("FALSE", "TRUE")

# labels - ttc
ttc_labs <- c("TTC = 3 s", "TTC = 5 s")
names(ttc_labs) <- c(as.factor(3), as.factor(5))

n_back_TRUE_automation <- ggplot(dat.eye.automation %>%
         dplyr::filter(n_back == TRUE), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  ggtitle("B") +
  scale_colour_viridis_c(option = "C") +
  annotate(
    'text',
    x = 0,
    y = -30,
    label = 'Reduced horizontal dispersion',
    fontface = 'bold', 
    size = 2.5
  ) +
  annotate(
    'text',
    x = 25,
    y = 18,
    label = 'Increased gaze concentration',
    fontface = 'bold',
    size = 2.5
  ) +
  annotate(
    'curve',
    x = 27, # Play around with the coordinates until you're satisfied
    y = 16,
    yend = 5,
    xend = 10,
    linewidth = .7,
    curvature = 0,
    arrow = arrow(length = unit(0.2, 'cm'))
  ) +
  annotate(
    'text',
    x = -25,
    y = 14,
    label = 'Rear-view mirror',
    fontface = 'bold', 
    size = 2.5
  ) +
  annotate(
    'text',
    x = 40,
    y = -20,
    label = 'Wing mirror',
    fontface = 'bold', 
    size = 2.5
  ) +
  annotate( # visual tunneling
    'rect',
    xmin = -3,
    xmax = 10,
    ymin = -10,
    ymax = 4,
    alpha = 0, # This was put back to 0.5
    size = .5,
    col = viridis(2)[2]
  ) +
   annotate( # rear-view mirror
    'rect',
    xmin = -35,
    xmax = -15,
    ymin = -3,
    ymax = 12,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
     annotate( # wing mirror
    'rect',
    xmin = 32,
    xmax = 48,
    ymin = -18,
    ymax = -1,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
    annotate(
    'curve',
    x = -10, # Play around with the coordinates until you're satisfied
    y = -27,
    yend = -12,
    xend = -7,
    linewidth = .7,
    curvature = -0.3,
    arrow = arrow(length = unit(0.2, 'cm'))
  ) +
  annotate(
    'curve',
    x = 20, # Play around with the coordinates until you're satisfied
    y = -27,
    yend = -10,
    xend = 18,
    linewidth = .7,
    curvature = 0.3,
    arrow = arrow(length = unit(0.2, 'cm'))
  ) +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        plot.title = element_text(size = 15, face = "bold"), 
        strip.text = element_text(face = "bold", size = 10)) 


n_back_FALSE_automation <- ggplot(dat.eye.automation %>%
         dplyr::filter(n_back == FALSE), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  ggtitle("A") +
  scale_colour_viridis_c(option = "C") +
  annotate( # visual tunneling
    'rect',
    xmin = -3,
    xmax = 10,
    ymin = -10,
    ymax = 4,
    alpha = 0, # This was put back to 0.5
    size = .5,
    col = viridis(2)[2]
  ) +
   annotate( # rear-view mirror
    'rect',
    xmin = -35,
    xmax = -15,
    ymin = -3,
    ymax = 12,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
     annotate( # wing mirror
    'rect',
    xmin = 32,
    xmax = 48,
    ymin = -18,
    ymax = -1,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
  annotate(
    'text',
    x = -25,
    y = 14,
    label = 'Rear-view mirror',
    fontface = 'bold', 
    size = 2.5
  ) +
  annotate(
    'text',
    x = 40,
    y = -20,
    label = 'Wing mirror',
    fontface = 'bold', 
    size = 2.5
  ) +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        plot.title = element_text(size = 15, face = "bold"), 
        strip.text = element_text(face = "bold", size = 10)) 

fig9 <- n_back_FALSE_automation + n_back_TRUE_automation + plot_layout(axes = "collect")

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/fig9.tiff"), plot = fig9, width = 16, height = 8, units = 'cm', dpi = 300, type = 'cairo')
```

## SD of horizontal gaze during manual driving: model fitting

```{r}
# distributions
ggplot(response.vehicle.eye %>%
                dplyr::filter(rt.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15), mapping = aes(x = sd_yaw_manual)) +
  geom_histogram(alpha = 0.5, bins = 50, col = "black") + 
  xlab("SD yaw") +
  facet_wrap(n_back ~ ttc_criticality.x) 

sd_yaw_manual_gaussian_maximal <- readRDS(here::here("takeover_performance_cogload_time_budget/Models/sd_yaw_manual_gaussian_maximal.rds"))

# initial model of sd_yaw
sd_yaw_manual_gaussian_maximal <- brm(data = response.vehicle.eye %>%
                             dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
                             dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
                             dplyr::mutate(ppid = as.factor(ppid)),
                           family = gaussian(),
                           bf(sd_yaw_manual ~ n_back * ttc_criticality_factor + (n_back * ttc_criticality_factor| ppid)),
                           prior = c(prior(student_t(3, 0, 2.5), class = "Intercept"),
                                     prior(student_t(3, 0, 2.5), class = "b")),
                           iter = 5000, warmup = 2000, chains = 2, cores = 2, seed = 13, 
                           control = list(adapt_delta = 0.95),
                           file = here::here("takeover_performance_cogload_time_budget/Models/sd_yaw_manual_gaussian_maximal"))

# posterior predictive checks
pp_check(sd_yaw_manual_gaussian_maximal, type = "stat_grouped", stat = "mean", group = "ttc_criticality_factor")
pp_check(sd_yaw_manual_gaussian_maximal, type = "stat_grouped", stat = "mean", group = "n_back")

pp_check(sd_yaw_manual_gaussian_maximal, type = "dens_overlay_grouped", group = "n_back", ndraws = 100)
pp_check(sd_yaw_manual_gaussian_maximal, type = "dens_overlay_grouped", group = "ttc_criticality_factor", ndraws = 100)
```

## SD of horizontal gaze during manual driving: model predictions

```{r}
print(summary(sd_yaw_manual_gaussian_maximal), digits = 5)
describe_posterior(sd_yaw_manual_gaussian_maximal, centrality = "mean")

#### predicted posterior means and distribution ####
predicted_draws = empty_grid %>%
  add_predicted_draws(sd_yaw_manual_gaussian_maximal)

expected_values = empty_grid %>%
  add_epred_draws(sd_yaw_manual_gaussian_maximal)

# predicted mean SD yaw  implied by the model as a function of TTC # setting re_formula = NA tells the function to not use any random effects - here we plot the n-back specific distributions 
predicted_sd_yaw_manual_ttc <- sd_yaw_manual_gaussian_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3), as.factor(5)),
                                    n_back = FALSE),
              re_formula = NA)

predicted_sd_yaw_manual_ttc %>% mean_hdi()

# margainal effect of TTC for SD of yaw
sd_yaw_manual_MER_TTC <- sd_yaw_manual_gaussian_maximal %>% 
  emmeans(~ ttc_criticality_factor,
          at = list(n_back = FALSE),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

sd_yaw_manual_MER_TTC %>% mean_hdi()


## predicted means for the effect of n-back on SD yaw
predicted_sd_yaw_manual_nback <- sd_yaw_manual_gaussian_maximal %>% 
  epred_draws(newdata = expand_grid(ttc_criticality_factor = c(as.factor(3)),
                                    n_back = c(FALSE, TRUE)),
              re_formula = NA)

predicted_sd_yaw_manual_nback  %>% mean_hdi()

# marginal effect of N-back of SD of yaw during manual driving
sd_yaw_manual_MER_nback <- sd_yaw_manual_gaussian_maximal %>% 
  emmeans(~ n_back,
          at = list(ttc_criticality_factor = as.factor(3)),
          epred = TRUE, re_formula = NA) %>% 
  contrast(method = "revpairwise") %>% 
  gather_emmeans_draws()

sd_yaw_manual_MER_nback %>% mean_hdi()
```

## SD of horizontal gaze during manual driving: visualising posteriors and means

```{r}
# posterior distribution
posterior_sdyaw <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)) %>%
  ggplot(aes(x = sd_yaw_manual, y = n_back)) +
  stat_pointinterval(aes(x = .epred), data = expected_values, .width = c(.50, .95), position = position_nudge(y = -0.35)) +
  stat_interval(aes(x = .prediction), data = predicted_draws, .width = c(.50, .80, .95, .99)) +
  geom_jitter(data = response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt > .15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x)), size = 2, height = .05, alpha = .3) +
  #geom_point(conditional_df_fitted[[3]], mapping = aes(x = estimate__, y = n_back), col = "white") +
  scale_y_discrete(labels = c('No N-B','N-B'), guide = guide_axis(angle = 90)) +
  scale_color_brewer("Posterior predictive interval") +
  ggtitle("A") +
  #xlim(.5, 3.5) +
  xlab(expression(SD[YAW]~ "(Â°)")) +
  ylab(" ") +
  #xlim(0, 2) +
  facet_wrap(~ ttc_criticality_factor, labeller = labeller(ttc_criticality_factor = ttc_labs)) +
  theme_bw() +
  theme(legend.position = "bottom", legend.direction = "horizontal", axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 8, face = "bold"), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10)) 

# predicted means
predicted_sd_yaw_manual_ttc_plot <- ggplot(predicted_sd_yaw_manual_ttc, aes(x = .epred, y = " ", fill = ttc_criticality_factor)) +
  stat_halfeye(alpha = .5) +
  ylab(NULL) +
  xlab(expression("Predicted" ~ mu ~ "of" ~ SD[YAW]~ "(Â°)")) +
  ggtitle("B") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  xlim(8, 14) +
  theme_bw() +
  theme(legend.position = c(.88, .6), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

# Average marginal effect for SD of yaw
sd_yaw_manual_MER_TTC_plot <- ggplot(sd_yaw_manual_MER_TTC, aes(x = .value, y = " ")) +
  stat_halfeye() +
  ylab(NULL) +
  xlab(expression(MER[SD[YAW]]~ "(Â°)")) +
  ggtitle("C") +
  scale_fill_discrete(name = "TTC", labels = c("3 s", "5 s")) +
  theme_bw() +
  theme(legend.position = c(.9, .7), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), axis.title.y = element_text(size = 11), axis.text.y = element_text(size = 11), title = element_text(size = 18), legend.title = element_text(size = 12), legend.text = element_text(size = 12), legend.key = element_blank(), legend.key.width = unit(0.3, 'cm'), legend.key.size = unit(0.1, 'cm'), plot.title = element_text(size = 15, face = "bold"), strip.text = element_text(face = "bold", size = 10))

fig10 <- posterior_sdyaw / (predicted_sd_yaw_manual_ttc_plot | sd_yaw_manual_MER_TTC_plot)

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/fig10.tiff"), plot = fig10, width = 16, height = 12, units = 'cm', dpi = 300, type = 'cairo')
```

# SD of horitzonal gaze during manual: dispersion plots

```{r}
# gaze concentration during manual driving
n_back_ttc_manual_disp_ttc5 <- ggplot(dat.eye.manual %>%
                                   dplyr::filter(ttc_criticality == 5), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_grid(ttc_criticality ~ n_back, labeller = labeller(n_back = l.labs, ttc_criticality = ttc_labs)) +
  ggtitle("B") +
  scale_colour_viridis_c(option = "C") +
  annotate( # dashboard area
    'rect',
    xmin = -10,
    xmax = 25,
    ymin = -30,
    ymax = -15,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
  annotate( # visual tunneling
    'rect',
    xmin = -3,
    xmax = 10,
    ymin = -10,
    ymax = 4,
    alpha = 0, # This was put back to 0.5
    size = .5,
    col = viridis(2)[2]
  ) +
    annotate(
    'text',
    x = 25,
    y = 18,
    label = 'Increased gaze concentration',
    fontface = 'bold',
    size = 2.5
  ) +
  annotate(
    'curve',
    x = 27, # Play around with the coordinates until you're satisfied
    y = 16,
    yend = 5,
    xend = 10,
    linewidth = .7,
    curvature = 0,
    arrow = arrow(length = unit(0.2, 'cm'))
  ) +
  annotate(
    'text',
    x = 10,
    y = -32,
    label = 'Dashboard area',
    fontface = 'bold', 
    size = 2.5
  ) +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        plot.title = element_text(size = 15, face = "bold"), 
        strip.text = element_text(face = "bold", size = 10))


n_back_ttc_manual_disp_ttc3 <- ggplot(dat.eye.manual %>%
                                   dplyr::filter(ttc_criticality == 3), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_grid(ttc_criticality ~ n_back, labeller = labeller(n_back = l.labs, ttc_criticality = ttc_labs)) +
  ggtitle("A") +
  scale_colour_viridis_c(option = "C") +
  annotate( # dashboard area
    'rect',
    xmin = -10,
    xmax = 25,
    ymin = -30,
    ymax = -15,
    alpha = 0, 
    size = .5,
    col = viridis(2)[2]
  ) +
  annotate( # visual tunneling
    'rect',
    xmin = -3,
    xmax = 10,
    ymin = -10,
    ymax = 4,
    alpha = 0, # This was put back to 0.5
    size = .5,
    col = viridis(2)[2]
  ) +
  annotate(
    'text',
    x = 10,
    y = -32,
    label = 'Dashboard area',
    fontface = 'bold', 
    size = 2.5
  ) +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        plot.title = element_text(size = 15, face = "bold"), 
        strip.text = element_text(face = "bold", size = 10))


fig11 <- n_back_ttc_manual_disp_ttc3 / n_back_ttc_manual_disp_ttc5 + plot_layout(axes = "collect")

# plot saving
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/fig11.tiff"), plot = fig11, width = 16, height = 16, units = 'cm', dpi = 300, type = 'cairo')
```

# SD of horitzonal gaze during manual: individual dispersion plots

```{r}
# relative size of  heterogenity effect for 2-back on mu
summary(sd_yaw_manual_gaussian_maximal)[["random"]][["ppid"]][2,1] / summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1]

# removing outliers and collisions from a specific dataframe
response.vehicle.eye.removed <- response.vehicle.eye %>%
  dplyr::ungroup() %>%
  dplyr::filter(rt.outlier == FALSE, ho.outlier == FALSE, ho.rt != 0, collision == 0, ho.rt >.15) %>%
  dplyr::mutate(ttc_criticality_factor = as.factor(ttc_criticality.x), ppid = as.factor(ppid))

# individual effects for SD of yaw during manual driving
ppid.effects <- as.data.frame(ranef(sd_yaw_manual_gaussian_maximal)) %>%
  dplyr::select(ppid.Estimate.n_backTRUE) %>%
  dplyr::mutate(ranef = ppid.Estimate.n_backTRUE + summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1]) %>%
  tibble::rownames_to_column("ppid")

ppid.effects$x <- 0

# CI interval for average effect
bayes.credible.intervals <- as.data.frame(summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][3:4])

# select random effects parameter 
ran.effects <- summary(sd_yaw_manual_gaussian_maximal)[["random"]][["ppid"]][2,1]

# strip plot of individual effects
strip_plot <- ggplot() +
  geom_jitter(ppid.effects, mapping = aes(x = x, y = ranef), width = .05, height = 0, size = 4,
              shape = 21, colour = "black", fill = viridis(5)[3], alpha = .95, stroke = 1) +
  scale_y_continuous(limits = c(-4.5, 3), breaks = seq(-4.5, 3, 1.5), labels = label_number(accuracy = 0.1)) +
  ylab(expression("N-back effect on" ~ mu ~ "of" ~ SD[YAW] ~ "during manual driving (Â°)")) +
  xlab("") + 
  ggtitle("A") +
  xlim(-1, 1) +
  geom_hline(aes(yintercept = bayes.credible.intervals$`l-95% CI`[2], linetype ="95% CI"), size = 1.5,  color = viridis(5)[3]) +
  geom_hline(aes(yintercept = bayes.credible.intervals$`u-95% CI`[2], linetype="95% CI"), size = 1.5,  color = viridis(5)[3]) +
  geom_hline(aes(yintercept = summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1], linetype = "beta_1"), size = 1.5, color = "black") +
  geom_hline(aes(yintercept = summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1] + 1.96 * ran.effects, linetype = "95% HI"), size = 1.5, color = viridis(5)[2]) +
  geom_hline(aes(yintercept = summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1] - 1.96 * ran.effects, linetype = "95% HI"), size = 1.5, color = viridis(5)[2]) +
  scale_linetype_manual(name = " ", values = c(2, 1, 1), labels = c(expression(CI[95]), expression(HI[95]), expression(beta[N])), guide = guide_legend(override.aes = list(color = c(viridis(5)[3], viridis(5)[2], "black")))) +
  scale_fill_manual(name = "Parameter", values = c(viridis(5)[2])) +
   annotate( # increased gaze concentration
    'rect',
    xmin = -.25,
    xmax = .25,
    ymin = -2.49,
    ymax = -2.24,
    alpha = 0.5, # This was put back to 0.5
    fill = turbo(5)[5],
    col = 'black'
  ) +
  annotate( # no difference in gaze concentration
    'rect',
    xmin = -.25,
    xmax = .25,
    ymin = -.1,
    ymax = .15,
    alpha = 0.5, # This was put back to 0.5
    fill = viridis(5)[4],
    col = 'black'
  ) +
  theme_bw() +
  coord_flip() + 
  theme(legend.position = c(.181, .60), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(),legend.key = element_blank(), legend.key.width = unit(0.2, 'cm'), axis.text.y = element_blank(), axis.ticks.y = element_blank(), legend.key.size = unit(.05, 'cm'), plot.title = element_text(size = 15, face = "bold"), axis.title.x = element_text(size = 11), axis.text.x = element_text(size = 11), title = element_text(size = 7), legend.title = element_text(size = 11), legend.text = element_text(size = 7)) 

# heterogenity intervals for the effect of N-back on SD of yaw during manual driving
summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1] + 1.96 * ran.effects
summary(sd_yaw_manual_gaussian_maximal)[["fixed"]][2,1] - 1.96 * ran.effects


# participant 3, beta_n = -0.065
p_3 <- ggplot(dat.eye.manual %>%
         dplyr::filter(ppid == 3), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  scale_colour_viridis_c(option = "C") +
  ggtitle(label = "B",
          subtitle = "Participant 3," ~ beta[N[3]] ~ "= -.065") +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        strip.text = element_text(face = "bold", size = 10),
        plot.subtitle = element_text(size = 12, colour = viridis(5)[4]),
        plot.title = element_text(size = 15, face = "bold"))


# participant 14, beta_n = .036
p_14 <- ggplot(dat.eye.manual %>%
         dplyr::filter(ppid == 14), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  scale_colour_viridis_c(option = "C") +
  ggtitle(label = " ",
          subtitle = "Participant 14," ~ beta[N[14]] ~ "= .036") +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        strip.text = element_text(face = "bold", size = 10),
        plot.subtitle = element_text(size = 12, colour = viridis(5)[4]),
        plot.title = element_text(size = 15, face = "bold"))


# participant 7, beta_n = -2.128
p_7 <- ggplot(dat.eye.manual %>%
         dplyr::filter(ppid == 7), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  scale_colour_viridis_c(option = "C") +
  ggtitle(label = "C",
          subtitle = "Participant 7," ~ beta[N[7]] ~ "= -2.128") +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        strip.text = element_text(face = "bold", size = 10),
        plot.subtitle = element_text(size = 12, colour = turbo(5)[5]),
        plot.title = element_text(size = 15, face = "bold"))


# participant 13, beta_n = -2.391
p_13 <- ggplot(dat.eye.manual %>%
         dplyr::filter(ppid == 13), mapping = aes(x = yaw, y = pitch)) +
  geom_density_2d(aes(col = ..level..), alpha = .5, binwidth = .00003) +
  facet_wrap(~ n_back, labeller = labeller(n_back = l.labs)) +
  scale_colour_viridis_c(option = "C") +
  ggtitle(label = " ",
          subtitle = "Participant 13," ~ beta[N[13]] ~ "= -2.391") +
  xlab("Yaw (Â°)") +
  ylab("Pitch (Â°)") +
  xlim(-50, 50) +
  scale_y_continuous(limits = c(-32, 20), breaks = seq(-30, 20, 15)) +
  theme_bw() +
  theme(legend.position = "none",
        axis.title.x = element_text(size = 11), 
        axis.text.x = element_text(size = 11), 
        axis.title.y = element_text(size = 11), 
        axis.text.y = element_text(size = 11), 
        title = element_text(size = 18),
        strip.text = element_text(face = "bold", size = 10),
        plot.title = element_text(size = 15, face = "bold"),
        plot.subtitle = element_text(size = 12, colour = turbo(5)[5]))


fig12 <- strip_plot / (p_3 | p_14) / (p_7 | p_13)
  
ggsave(here::here("takeover_performance_cogload_time_budget/Figures/fig12.tiff"), plot = fig12, width = 16, height = 18, units = 'cm', dpi = 300, type = 'cairo')
```

